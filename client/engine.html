<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <title>My first three.js app</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
        <style>
            /*With help from https://www.w3schools.com/howto/howto_js_collapse_sidepanel.asp*/
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            .sidepanel {
                height: 51vw; /* Specify a height */
                width: 250px; 
                position: absolute; /* Stay in place */
                z-index: 1; /* Stay on top */
                top: 0;
                left: 0;
                background-color: rgb(255, 255, 255, .8); /* Black*/
                overflow-x: hidden; /* Disable horizontal scroll */
                padding-top: 60px; /* Place content 60px from the top */
                transition: 0.5s; /* 0.5 second transition effect to slide in the sidepanel */
            }
            button {
                padding-top: 60px;
            }
            header {
                padding-left: 250px;
            }
		</style>
    </head>
	<body>
        <header>
            Shared World Generator
        </header>
        <div class="sidepanel">
            <div class="container-fluid">
                <div class="row">
                    <div class="col">
                        <button class="btn btn-primary" id = "saveBtn">Save</button>
                    </div>
                    <div class="col">
                        <p id="guid">ID: Unidentified</p>
                    </div>
                </div>
                <div class="row">
                </div>
                <div class="row">
                    <div class="col">
                        <button type="button" class="btn btn-light" id="cubeBtn">Cube</button>
                    </div>
                    <div class="col">
                        <button type="button" class="btn btn-light" id="coneBtn">Cone</button>
                    </div>
                    <div class="col">
                        <button type="button" class="btn btn-light" id="cylinderBtn">Cylinder</button>
                    </div>
                </div>
                <!-- <button type="button" class="btn btn-light" id="coneBtn">Cone</button> -->
                <!-- <button type="button" class="btn btn-light" id="cylinderBtn">Cylinder</button> -->
            </div>
        </div>
        <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
        <script src="/three.js"></script>
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            })

            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }
            animate();

            let entities = [];
            
            var boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );
            let coneGeometry = new THREE.ConeGeometry(1, 1, 20);
            let cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 20);
            var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            // entities.push(new THREE.Mesh(boxGeometry, material));
            // scene.add( entities[0] );

            // with help from https://threejs.org/docs/#api/en/core/Raycaster
            var raycaster = new THREE.Raycaster();
            var mouseMovement = new THREE.Vector2();
            let mousePos = new THREE.Vector2();
            function onMouseMove( event ) {
                mouseMovement.x = event.movementX * (1/600);
                mouseMovement.y = event.movementY * (1/600);

                mousePos.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mousePos.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                if (event.buttons != 0){
                    camera.rotation.y -= mouseMovement.x;
                    camera.rotation.x -= mouseMovement.y;
                }
            }
            window.addEventListener('mousemove', onMouseMove);

            function moveCamera(e){
                var cameraFwd = new THREE.Vector3();
                var cameraRight = new THREE.Vector3();
                camera.getWorldDirection(cameraFwd);
                cameraRight.crossVectors(new THREE.Vector3(0, 1, 0), cameraFwd);
                let cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, cameraFwd);
                cameraUp.crossVectors(cameraFwd, cameraRight);
                if (e.key == "w"){
                    camera.position = camera.position.add(cameraFwd.multiplyScalar(.1));
                }
                if (e.key == "s"){
                    camera.position = camera.position.add(cameraFwd.multiplyScalar(-.1));
                }
                if (e.key == "a"){
                    camera.position = camera.position.add(cameraRight.multiplyScalar(.1));
                }
                if (e.key == "d"){
                    camera.position = camera.position.add(cameraRight.multiplyScalar(-.1));
                }
            }
            window.addEventListener('keydown', moveCamera);

            function addEntity(geometry, newName) {
                let cameraFwd = new THREE.Vector3();
                let mesh = new THREE.Mesh(geometry, material);
                // let camPos = camera.position.clone();
                mesh.position.add(camera.position).add(camera.getWorldDirection(cameraFwd).multiplyScalar(5));
                mesh.name = newName;
                // camPos.add(camera.getWorldDirection(cameraFwd).multiplyScalar(5)).copy(mesh.position);
                entities.push(mesh);
                scene.add(mesh);
            }

            document.querySelector("#cubeBtn").addEventListener('click', () => {
                addEntity(boxGeometry, "Cube");
            })

            document.querySelector("#coneBtn").addEventListener('click', () => {
                addEntity(coneGeometry, "Cone");
            })

            document.querySelector("#cylinderBtn").addEventListener('click', () => {
                addEntity(cylinderGeometry, "Cylinder");
            })

            let selected;
            let selectedOutline;
            renderer.domElement.addEventListener('click', () => {
                scene.remove(selectedOutline);
                raycaster.setFromCamera(mousePos, camera);
                let intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length == 0)
                {
                    selected = null;
                    return;
                }
                let hitMesh = false;
                let firstMeshIndex = 0;
                for (; firstMeshIndex < intersects.length; ++firstMeshIndex){
                    if (intersects[firstMeshIndex].object.type == "Mesh"){
                        hitMesh = true;
                        selected = intersects[firstMeshIndex].object;
                        selectedOutline = new THREE.LineSegments(selected.geometry, new THREE.LineBasicMaterial({
                            color: 0xffffff,
                            linewidth: 1,
                            linecap: 'round', //ignored by WebGLRenderer
                            linejoin:  'round' //ignored by WebGLRenderer
                        }));
                        // selectedOutline.position = selected.object.position;
                        selectedOutline.position.copy(selected.position);
                        scene.add(selectedOutline);
                        return;
                    }
                }
                if (!hitMesh){
                    selected = null;
                }
            })

            window.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'Delete':
                        scene.remove(selected);
                        scene.remove(selectedOutline);
                }
            })

            // create grid, with help from https://threejs.org/docs/index.html#api/en/helpers/GridHelper
            var size = 10;
            var divisions = 10;
            var gridHelper = new THREE.GridHelper( size, divisions );
            scene.add( gridHelper );

            document.querySelector("#saveBtn").addEventListener('click', (e) => {
                let entitiesStr = JSON.stringify(getSimplifiedEntities());
                let xhr = new XMLHttpRequest();
                xhr.open('POST', '/addOrUpdateScene');
                xhr.send(entitiesStr);
            })

            window.onload = () => {
                let isNew = window.location.href.split('?')[1].split('=')[1];
                if (isNew == "true") {
                    document.querySelector('#guid').innerHTML = "ID: " + getNewId();
                }
            }

            function getNewId() {
                let xhr = new XMLHttpRequest();
                xhr.open('GET', '/new');
                xhr.onload = () => {
                    console.log(xhr.responseText);
                    document.querySelector('#guid').innerHTML = "ID: " + xhr.responseText;
                }
                xhr.send();
            }

            function getSimplifiedEntities() {
                let simplified = [];
                entities.forEach((ent) => {
                    let simpleObj = {};
                    simpleObj.name = ent.name;
                    simple.color = ent.material.color;
                    simple.position = ent.position;
                    simple.rotation = ent.rotation;
                    simplified.push(simpleObj);
                })
            }
        </script>
	</body>
</html>